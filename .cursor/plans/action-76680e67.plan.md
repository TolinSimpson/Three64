<!-- 76680e67-e3be-40c2-88ce-c4a49323e60d 8d48f4f9-1604-4ce6-a359-eda215606679 -->
# Add configurable runtime actions (event.js) and wire components

### Scope

- Create `src/runtime/event.js` with an action registry, schema metadata, and an executor for action objects/arrays.
- Update `src/runtime/component.js` to add a default `onEvent(name, payload)` that can execute configured actions or fall back to emitting a string event.
- Update `src/runtime/rigidbody.js` to support `onCollisionEvent` as either a string (emit) or an action object/array (execute).
- Add `src/assets/config/action-manifest.json` listing action types and parameters for Blender.
- Optional: Extend `src/runtime/volume.js` to support actions for `onEnter/onExit/onStay` in addition to strings.

### Action schema (concise)

Each action is an object with `{ type: string, params: object }`. Components can store one action or an array of actions in their `options.events.*` fields.

Built-in actions in `event.js`:

- AddItem
  - params: `{ target: "player|self", item: { id?, name, quantity?, maxStack?, isConsumable?, isEquipable?, equipKey?, customProps? } }`
- ModifyStatistic
  - params: `{ name: string, op: "add|set|setMax|setMin|addOverTime", value?: number, duration?: number, easing?: string, keepRatio?: boolean, target?: "self|player" }`
- SendComponentMessage
  - params: `{ target: "self|byName|player", component: string, method: string, args?: any[], objectName?: string }`

### Event execution API (event.js)

- `ActionRegistry.register(id, { label, params, handler })`
- `executeAction(ctx, action, payload)` and `executeActions(ctx, actions, payload)` where `ctx = { game, object, component }`.
- Export `listActionsWithParams()` to feed Blender UI.

### Component integration

- In `component.js`:
  - Add `onEvent(name, payload)` default:
    - Lookup `this.options?.events?.[name]`.
    - If string: `game.eventSystem.emit(nameString, payload)`.
    - If object/array: `executeActions({ game, object: this.object, component: this }, actions, payload)`.
  - Add helper `triggerConfiguredEvent(key, payload)`.

### Rigidbody integration

- In `FixedUpdate`, when collision is detected:
  - If `onCollisionEvent` is string: keep current `emit` behavior.
  - If object/array: call `executeActions` with context and a payload like `{ point, normal, distance, targetName, sourceObject }`.

### Blender support

- Add `src/assets/config/action-manifest.json` with concise entries:
  - Example:
```json
{
  "actions": [
    { "id": "AddItem", "label": "Add Item", "params": ["target", "item"] },
    { "id": "ModifyStatistic", "label": "Modify Statistic", "params": ["name", "op", "value", "duration", "easing", "keepRatio", "target"] },
    { "id": "SendComponentMessage", "label": "Send Component Message", "params": ["target", "component", "method", "args", "objectName"] }
  ]
}
```

- `build.js` already copies `src/assets/config/**` â†’ `public/build/assets/config/**`, so no build change needed.

### Example usage

- In a component's options:
```json
{
  "events": {
    "onCollision": [
      { "type": "ModifyStatistic", "params": { "name": "health", "op": "add", "value": -10, "target": "player" } },
      { "type": "SendComponentMessage", "params": { "target": "self", "component": "Rigidbody", "method": "zeroVelocity" } }
    ]
  }
}
```

- Or simple string for backward compatibility:
```json
{ "events": { "onCollision": "RigidbodyCollision" } }
```


### Notes

- Uses existing `Inventory`, `Statistic`, and `EventSystem` APIs.
- Backward compatible with existing string-based events.
- Keeps action execution side-effect free unless an action handler explicitly changes state.

### To-dos

- [ ] Create src/runtime/event.js with registry, executor, built-in actions
- [ ] Add onEvent/triggerConfiguredEvent to component.js and wire into options.events
- [ ] Allow rigidbody onCollisionEvent to accept action object/array and execute
- [ ] Add src/assets/config/action-manifest.json for Blender dropdown
- [ ] Extend volume.js to support actions for onEnter/Exit/Stay (optional)